// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package db

import (
	"context"
	"database/sql"
)

const addToCart = `-- name: AddToCart :exec
INSERT INTO cart_items (id, session_id, user_id, product_id, quantity, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
`

type AddToCartParams struct {
	ID        string         `db:"id" json:"id"`
	SessionID sql.NullString `db:"session_id" json:"session_id"`
	UserID    sql.NullString `db:"user_id" json:"user_id"`
	ProductID string         `db:"product_id" json:"product_id"`
	Quantity  int64          `db:"quantity" json:"quantity"`
}

func (q *Queries) AddToCart(ctx context.Context, arg AddToCartParams) error {
	_, err := q.db.ExecContext(ctx, addToCart,
		arg.ID,
		arg.SessionID,
		arg.UserID,
		arg.ProductID,
		arg.Quantity,
	)
	return err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items WHERE session_id = ? OR user_id = ?
`

type ClearCartParams struct {
	SessionID sql.NullString `db:"session_id" json:"session_id"`
	UserID    sql.NullString `db:"user_id" json:"user_id"`
}

func (q *Queries) ClearCart(ctx context.Context, arg ClearCartParams) error {
	_, err := q.db.ExecContext(ctx, clearCart, arg.SessionID, arg.UserID)
	return err
}

const getCartBySession = `-- name: GetCartBySession :many
SELECT c.id, c.session_id, c.user_id, c.product_id, c.product_variant_id, c.quantity, c.created_at, c.updated_at, 
       p.name, p.price_cents, p.slug, 
       COALESCE(pi.image_url, '') as image_url
FROM cart_items c
JOIN products p ON c.product_id = p.id
LEFT JOIN product_images pi ON p.id = pi.product_id AND (pi.is_primary = 1 OR pi.display_order = 1)
WHERE c.session_id = ?
GROUP BY c.id
ORDER BY c.created_at DESC
`

type GetCartBySessionRow struct {
	ID               string         `db:"id" json:"id"`
	SessionID        sql.NullString `db:"session_id" json:"session_id"`
	UserID           sql.NullString `db:"user_id" json:"user_id"`
	ProductID        string         `db:"product_id" json:"product_id"`
	ProductVariantID sql.NullString `db:"product_variant_id" json:"product_variant_id"`
	Quantity         int64          `db:"quantity" json:"quantity"`
	CreatedAt        sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt        sql.NullTime   `db:"updated_at" json:"updated_at"`
	Name             string         `db:"name" json:"name"`
	PriceCents       int64          `db:"price_cents" json:"price_cents"`
	Slug             string         `db:"slug" json:"slug"`
	ImageUrl         string         `db:"image_url" json:"image_url"`
}

func (q *Queries) GetCartBySession(ctx context.Context, sessionID sql.NullString) ([]GetCartBySessionRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartBySessionRow{}
	for rows.Next() {
		var i GetCartBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.PriceCents,
			&i.Slug,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartByUser = `-- name: GetCartByUser :many
SELECT c.id, c.session_id, c.user_id, c.product_id, c.product_variant_id, c.quantity, c.created_at, c.updated_at, 
       p.name, p.price_cents, p.slug, 
       COALESCE(pi.image_url, '') as image_url
FROM cart_items c
JOIN products p ON c.product_id = p.id
LEFT JOIN product_images pi ON p.id = pi.product_id AND (pi.is_primary = 1 OR pi.display_order = 1)
WHERE c.user_id = ?
GROUP BY c.id
ORDER BY c.created_at DESC
`

type GetCartByUserRow struct {
	ID               string         `db:"id" json:"id"`
	SessionID        sql.NullString `db:"session_id" json:"session_id"`
	UserID           sql.NullString `db:"user_id" json:"user_id"`
	ProductID        string         `db:"product_id" json:"product_id"`
	ProductVariantID sql.NullString `db:"product_variant_id" json:"product_variant_id"`
	Quantity         int64          `db:"quantity" json:"quantity"`
	CreatedAt        sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt        sql.NullTime   `db:"updated_at" json:"updated_at"`
	Name             string         `db:"name" json:"name"`
	PriceCents       int64          `db:"price_cents" json:"price_cents"`
	Slug             string         `db:"slug" json:"slug"`
	ImageUrl         string         `db:"image_url" json:"image_url"`
}

func (q *Queries) GetCartByUser(ctx context.Context, userID sql.NullString) ([]GetCartByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartByUserRow{}
	for rows.Next() {
		var i GetCartByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.PriceCents,
			&i.Slug,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartItemCount = `-- name: GetCartItemCount :one
SELECT COALESCE(SUM(quantity), 0) as count
FROM cart_items 
WHERE session_id = ? OR user_id = ?
`

type GetCartItemCountParams struct {
	SessionID sql.NullString `db:"session_id" json:"session_id"`
	UserID    sql.NullString `db:"user_id" json:"user_id"`
}

func (q *Queries) GetCartItemCount(ctx context.Context, arg GetCartItemCountParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCartItemCount, arg.SessionID, arg.UserID)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getCartTotal = `-- name: GetCartTotal :one
SELECT COALESCE(SUM(c.quantity * p.price_cents), 0) as total_cents
FROM cart_items c
JOIN products p ON c.product_id = p.id
WHERE c.session_id = ? OR c.user_id = ?
`

type GetCartTotalParams struct {
	SessionID sql.NullString `db:"session_id" json:"session_id"`
	UserID    sql.NullString `db:"user_id" json:"user_id"`
}

func (q *Queries) GetCartTotal(ctx context.Context, arg GetCartTotalParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCartTotal, arg.SessionID, arg.UserID)
	var total_cents interface{}
	err := row.Scan(&total_cents)
	return total_cents, err
}

const getExistingCartItem = `-- name: GetExistingCartItem :one
SELECT id, quantity FROM cart_items 
WHERE (session_id = ? OR user_id = ?) AND product_id = ?
LIMIT 1
`

type GetExistingCartItemParams struct {
	SessionID sql.NullString `db:"session_id" json:"session_id"`
	UserID    sql.NullString `db:"user_id" json:"user_id"`
	ProductID string         `db:"product_id" json:"product_id"`
}

type GetExistingCartItemRow struct {
	ID       string `db:"id" json:"id"`
	Quantity int64  `db:"quantity" json:"quantity"`
}

func (q *Queries) GetExistingCartItem(ctx context.Context, arg GetExistingCartItemParams) (GetExistingCartItemRow, error) {
	row := q.db.QueryRowContext(ctx, getExistingCartItem, arg.SessionID, arg.UserID, arg.ProductID)
	var i GetExistingCartItemRow
	err := row.Scan(&i.ID, &i.Quantity)
	return i, err
}

const mergeCartOnLogin = `-- name: MergeCartOnLogin :exec
UPDATE cart_items 
SET user_id = ?, session_id = NULL, updated_at = CURRENT_TIMESTAMP
WHERE session_id = ?
  AND NOT EXISTS (
    SELECT 1 FROM cart_items c2 
    WHERE c2.user_id = ? AND c2.product_id = cart_items.product_id
  )
`

type MergeCartOnLoginParams struct {
	UserID    sql.NullString `db:"user_id" json:"user_id"`
	SessionID sql.NullString `db:"session_id" json:"session_id"`
}

func (q *Queries) MergeCartOnLogin(ctx context.Context, arg MergeCartOnLoginParams) error {
	_, err := q.db.ExecContext(ctx, mergeCartOnLogin, arg.UserID, arg.SessionID)
	return err
}

const removeCartItem = `-- name: RemoveCartItem :exec
DELETE FROM cart_items WHERE id = ?
`

func (q *Queries) RemoveCartItem(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, removeCartItem, id)
	return err
}

const updateCartItemQuantity = `-- name: UpdateCartItemQuantity :exec
UPDATE cart_items 
SET quantity = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateCartItemQuantityParams struct {
	Quantity int64  `db:"quantity" json:"quantity"`
	ID       string `db:"id" json:"id"`
}

func (q *Queries) UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) error {
	_, err := q.db.ExecContext(ctx, updateCartItemQuantity, arg.Quantity, arg.ID)
	return err
}
