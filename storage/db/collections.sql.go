// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: collections.sql

package db

import (
	"context"
	"database/sql"
)

const addToCollection = `-- name: AddToCollection :one
INSERT INTO collection_items (id, collection_id, product_id, quantity, notes, created_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(collection_id, product_id) 
DO UPDATE SET quantity = excluded.quantity, notes = excluded.notes
RETURNING id, collection_id, product_id, quantity, notes, created_at
`

type AddToCollectionParams struct {
	ID           string         `db:"id" json:"id"`
	CollectionID string         `db:"collection_id" json:"collection_id"`
	ProductID    string         `db:"product_id" json:"product_id"`
	Quantity     sql.NullInt64  `db:"quantity" json:"quantity"`
	Notes        sql.NullString `db:"notes" json:"notes"`
}

func (q *Queries) AddToCollection(ctx context.Context, arg AddToCollectionParams) (CollectionItem, error) {
	row := q.db.QueryRowContext(ctx, addToCollection,
		arg.ID,
		arg.CollectionID,
		arg.ProductID,
		arg.Quantity,
		arg.Notes,
	)
	var i CollectionItem
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.ProductID,
		&i.Quantity,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO user_collections (id, user_id, name, description, created_at, updated_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, user_id, name, description, is_quote_requested, quote_request_id, created_at, updated_at
`

type CreateCollectionParams struct {
	ID          string         `db:"id" json:"id"`
	UserID      string         `db:"user_id" json:"user_id"`
	Name        string         `db:"name" json:"name"`
	Description sql.NullString `db:"description" json:"description"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (UserCollection, error) {
	row := q.db.QueryRowContext(ctx, createCollection,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
	)
	var i UserCollection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.IsQuoteRequested,
		&i.QuoteRequestID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM user_collections
WHERE id = ? AND user_id = ?
`

type DeleteCollectionParams struct {
	ID     string `db:"id" json:"id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteCollection(ctx context.Context, arg DeleteCollectionParams) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, arg.ID, arg.UserID)
	return err
}

const getCollection = `-- name: GetCollection :one
SELECT id, user_id, name, description, is_quote_requested, quote_request_id, created_at, updated_at FROM user_collections
WHERE id = ? AND user_id = ?
`

type GetCollectionParams struct {
	ID     string `db:"id" json:"id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) GetCollection(ctx context.Context, arg GetCollectionParams) (UserCollection, error) {
	row := q.db.QueryRowContext(ctx, getCollection, arg.ID, arg.UserID)
	var i UserCollection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.IsQuoteRequested,
		&i.QuoteRequestID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionItems = `-- name: GetCollectionItems :many
SELECT 
    ci.id,
    ci.collection_id,
    ci.product_id,
    ci.quantity,
    ci.notes,
    ci.created_at,
    p.name AS product_name,
    p.slug AS product_slug,
    p.price_cents,
    p.short_description,
    pi.image_url AS primary_image_url
FROM collection_items ci
INNER JOIN products p ON ci.product_id = p.id
LEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = TRUE
WHERE ci.collection_id = ?
ORDER BY ci.created_at DESC
`

type GetCollectionItemsRow struct {
	ID               string         `db:"id" json:"id"`
	CollectionID     string         `db:"collection_id" json:"collection_id"`
	ProductID        string         `db:"product_id" json:"product_id"`
	Quantity         sql.NullInt64  `db:"quantity" json:"quantity"`
	Notes            sql.NullString `db:"notes" json:"notes"`
	CreatedAt        sql.NullTime   `db:"created_at" json:"created_at"`
	ProductName      string         `db:"product_name" json:"product_name"`
	ProductSlug      string         `db:"product_slug" json:"product_slug"`
	PriceCents       int64          `db:"price_cents" json:"price_cents"`
	ShortDescription sql.NullString `db:"short_description" json:"short_description"`
	PrimaryImageUrl  sql.NullString `db:"primary_image_url" json:"primary_image_url"`
}

func (q *Queries) GetCollectionItems(ctx context.Context, collectionID string) ([]GetCollectionItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionItems, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionItemsRow{}
	for rows.Next() {
		var i GetCollectionItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.ProductID,
			&i.Quantity,
			&i.Notes,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductSlug,
			&i.PriceCents,
			&i.ShortDescription,
			&i.PrimaryImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollections = `-- name: GetUserCollections :many
SELECT 
    c.id,
    c.user_id,
    c.name,
    c.description,
    c.is_quote_requested,
    c.quote_request_id,
    c.created_at,
    c.updated_at,
    COUNT(ci.id) as item_count
FROM user_collections c
LEFT JOIN collection_items ci ON c.id = ci.collection_id
WHERE c.user_id = ?
GROUP BY c.id
ORDER BY c.updated_at DESC
`

type GetUserCollectionsRow struct {
	ID               string         `db:"id" json:"id"`
	UserID           string         `db:"user_id" json:"user_id"`
	Name             string         `db:"name" json:"name"`
	Description      sql.NullString `db:"description" json:"description"`
	IsQuoteRequested sql.NullBool   `db:"is_quote_requested" json:"is_quote_requested"`
	QuoteRequestID   sql.NullString `db:"quote_request_id" json:"quote_request_id"`
	CreatedAt        sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt        sql.NullTime   `db:"updated_at" json:"updated_at"`
	ItemCount        int64          `db:"item_count" json:"item_count"`
}

func (q *Queries) GetUserCollections(ctx context.Context, userID string) ([]GetUserCollectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCollectionsRow{}
	for rows.Next() {
		var i GetUserCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.IsQuoteRequested,
			&i.QuoteRequestID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCollectionAsQuoted = `-- name: MarkCollectionAsQuoted :exec
UPDATE user_collections
SET is_quote_requested = TRUE, quote_request_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
`

type MarkCollectionAsQuotedParams struct {
	QuoteRequestID sql.NullString `db:"quote_request_id" json:"quote_request_id"`
	ID             string         `db:"id" json:"id"`
	UserID         string         `db:"user_id" json:"user_id"`
}

func (q *Queries) MarkCollectionAsQuoted(ctx context.Context, arg MarkCollectionAsQuotedParams) error {
	_, err := q.db.ExecContext(ctx, markCollectionAsQuoted, arg.QuoteRequestID, arg.ID, arg.UserID)
	return err
}

const removeFromCollection = `-- name: RemoveFromCollection :exec
DELETE FROM collection_items
WHERE collection_id = ? AND product_id = ?
`

type RemoveFromCollectionParams struct {
	CollectionID string `db:"collection_id" json:"collection_id"`
	ProductID    string `db:"product_id" json:"product_id"`
}

func (q *Queries) RemoveFromCollection(ctx context.Context, arg RemoveFromCollectionParams) error {
	_, err := q.db.ExecContext(ctx, removeFromCollection, arg.CollectionID, arg.ProductID)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE user_collections 
SET name = ?, description = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, is_quote_requested, quote_request_id, created_at, updated_at
`

type UpdateCollectionParams struct {
	Name        string         `db:"name" json:"name"`
	Description sql.NullString `db:"description" json:"description"`
	ID          string         `db:"id" json:"id"`
	UserID      string         `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (UserCollection, error) {
	row := q.db.QueryRowContext(ctx, updateCollection,
		arg.Name,
		arg.Description,
		arg.ID,
		arg.UserID,
	)
	var i UserCollection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.IsQuoteRequested,
		&i.QuoteRequestID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCollectionItem = `-- name: UpdateCollectionItem :one
UPDATE collection_items
SET quantity = ?, notes = ?
WHERE id = ?
RETURNING id, collection_id, product_id, quantity, notes, created_at
`

type UpdateCollectionItemParams struct {
	Quantity sql.NullInt64  `db:"quantity" json:"quantity"`
	Notes    sql.NullString `db:"notes" json:"notes"`
	ID       string         `db:"id" json:"id"`
}

func (q *Queries) UpdateCollectionItem(ctx context.Context, arg UpdateCollectionItemParams) (CollectionItem, error) {
	row := q.db.QueryRowContext(ctx, updateCollectionItem, arg.Quantity, arg.Notes, arg.ID)
	var i CollectionItem
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.ProductID,
		&i.Quantity,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
